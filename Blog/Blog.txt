Blog
========

Blog #8 (23/04/2014)
====================
o	ImageTiler: we already had achieved the hiding of data through bit shifting for one image.
	This wrote a byte of data to the end of the image. However, the instructions were to split up this byte
	and write a piece of it at the end of every separate tile in our tiled image. This was quickly fixed, but
	then we got stuck at the decoding of this. Since there was the possibility of our tiles getting randomly
	rotated, we had to find a way to let our decoder know where in the image to read. We then got familiar with
	the usage of HashCodes to identify the different pieces of hidden data. It took us a while to get this working,
	but it turned out to be exactly what we needed to finish our application.


o	CryptoLocker: we found out that in some scenarios, the decryption using our algorithms caused faulty outputs.
	When writing our encrypted message from our program itself, everything worked smoothly, but once we tried
	decrypting after reading some text from a text-file, the amount of bytes read were for some reason not the
	same as when we	extracted the text from a local variable. The problem here was that the AES-128 decryption
	only accepts an encrypted amount of bytes that is divisible by 16. We read a lot about using padding schemes,
	but didn’t manage to implement this successfully. Instead we found a work-around that adds “\0” for each
	missing byte in the message to make it divisible by 16. We are not sure this is a clean way of working, but
	it works like a charm.

o	ANPR Application: we have been working on some classes and ideas here as well, mainly focussed on optimising
	the classes representing the Roads and Cameras for our ANPR application, as well as writing a Camera Manager
	class for it. We will make sure to update our blog very soon with our progress.



Blog #7 (19/04/2014)
====================
Over the last 2 days, we have been focussing on planning out every separate part of our application.
We started out by brainstorming about a full simulation of one car, since we will work with the car-based approach. 
We already wrote our Car-class last week, including its necessary properties. 
The only thing left to do here is giving it methods that will perform the actions. 
These actions will look something like: initiate, accelerate, decelerate, stop. 
We then thought about the implementation of these methods, but soon found out that they will have to be linked to certain Road-properties. 
So we temporary put the Car-methods aside and thought about the necessary Road-class. 
For now we will only be thinking about straight lines representing the streets, 
so we're not calculating in things like certain curves in a street or upward/downward going streets. 
Although key properties are: start coordinates, end coordinates and intersections. 
There was one problem here, we weren't really sure of how to ‘tell’ this street it had ANPR cameras. 
We thought of two ways of how to accomplish this: 
one way would be to give every street object a list with its cameras, 
the other would be to give every street- and camera object an ID, and let these interact with each other through some sort of look-up table. 
An advantage of using the second way would be that we can use these same camera ID’s in our Camera-manager class, that will hold the relation between a camera and its location, but also between the cameras mutually.
We’re making a few adjustments to the cryptolocker so you can choose where to store the private, public keys & the encrypted message on your system.


Blog #6 (12/04/2014)
====================
We have been thinking a lot about the architecture of how our program would look like. We first wanted to start out by
using geometric figures to calculate the distance between 2 points, so we drew this out on paper to get an idea of what
our algorithms would look like. While we were doing this, we remembered the fact that you stated the earth of course
isn't flat, so this would have an impact on longer distances. We then started thinking about the earth as a sphere, but
after research found out it was actually an ellipsoid. Knowing this, we figured calculating 2D distances inside for
example a square wouldn't really be accurate enough to please us, so we started searching for a suitable library we
could use. This is when we found Michael Gavaghan's Java Geodesy Library for GPS using Vincenty’s Formulae.
We implemented it into a little test project and started playing around with it until we felt familiar with it.
We found this a good first step of our project, since we now had an accurate representation of the earth.
After establishing that, we started thinking about other parts that were necessary in order to start our real simulation.
We decided to start off by writing a simple Camera class that would hold an ID and GPS-coordinates. For now we thought
it would be okay to just generate some random coordinates. We started off by creating a camera with basic properties:
ID, longitude & latitude and subsequently writing these to a text file.
While generating random coordinates for now seemed like a good idea, there of course is the disadvantage our camera
would be situated off-road or in water. Hopefully there's a nice, clean and efficient way to do this in the future?
This is an extremely interesting topic, from both a theoretical and practical perspective. How critical are accuracy
and correctness? Will identifying sea as land or vice-versa be a catastrophic failure? We will probably be needing
OpenStreetMaps or GoogleMaps for this, but decided to not run ahead of ourselves and leave this aside for now.

We wrote the output of the camera to a text file. For now it’s just written as plain text, but we will probably going
to try it out with XML or JSON tomorrow to see which one is actually faster. As we discussed on our meeting, JSON will
probably win this race, but XML might be stricter and has support for schemas and namespaces. In my opinion JSON is
very useful when developing a web application where fast, compact and convenient serialisation of data is required.
JSON might be the best tool for sharing data because the data is stored in arrays and records, while XML stores data
in trees and XML allows you to include data types like images, charts, and graphs.
Additionally, XML offers options for transferring the structure, or format, of the data along with the actual data.
JSON only offers options for transferring data without formatting, and only using traditional data formats. Next thing
we played around with was the auto incrementation of the ID’s of the camera’s. Let's play with this thought, we will
save the next member with an object. Imagine the following series:


Create instance1 of Camera, id=1, seq=1
Create instance2, id=2, seq=2 
Serialize instance1, id=1, seq=2
Create instance3, id=3, seq=3
Deserialize instance1, set seq=2
Create instance4, id=3, seq=3
So, we've got 2 instances, (instance3 and instance4) with the same id.
If we really want to serialize the state, should we make a separate class (and instance) for the sequence?
Probably. But it still should be a static property of the class.

class Sequence implements Serializable {

	private static Sequence seq = new Sequence();
	private int nextInt = 1;
	
	public static int nextId(){
		return seq.nextInt++;
	}

	public Object readResolve(){
		return seq;
	}
}

We should (de)serialize the sequence separately apparently, and set it to the Sequence class with separate
getters/setters. Notice that the sequence number may be accessed from more than 1 threads, so the access to it should
be synchronized.

After now having both a representation of the earth and the camera's, we started to brainstorm again about what
other part of the program we could 'chop off' into a smaller application that would be easy to implement later on.
We started thinking about the output that would need to be generated into a flat file whenever a car would pass one
of the camera's. We agreed that this part of the application had to be very error-proof  and extendable, since we will
probably alter it quite a lot in the future. With this thought in mind, we knew it would be a bad idea to write the
different fields hardcoded, but that we would probably be better off by writing a class that would represent one line
of data, holding all the different fields. This way data validation would become a lot easier, but also the getting and
setting of the actual data would be much more organised. Another advantage would of course be, as stated before, the 
fact that altering the structure of our data fields would become very easy in the future. Another thought we had was
our scepticism about the new-line escape characters and possible bugs that would show up while using them.
We started reading some documentation online and were pleased to very soon find the possibility of using
System.getProperty("line.separator"). After all the years of using Java, we had never come across this simple
possibility in Java. It goes without speaking that from now on, we will keep on using this platform-independent way of
adding escape characters. We now decided we were ready to write our text file writer using an instance of
java.io.BufferedWriter and perhaps change it to binary-writing in the future. We finished this standalone program as
well, so now have ended up with:

	- Geodesy Program capable of doing exact calculations
	- Camera generator
	- "DataLine" class representing one line of data to be written
	- FileWriter class
	
	
We have also just finished writing 0's on all the USB flash drives and SD cards. OFF TO POOLE :-) !




Blog #5 (09/04/2014)
====================
Apparently the maximum amount of cars passing the most busy camera is around 165 000. I wonder how it would work out writing all of these to the database
and thats for 1 cameras? We read somewhere there are around 8000 cameras places around the UK. Well the police said 2000 some other source said 4000 etc..
Thats going to be alot of database traffic. Did some small calculations thats going to be around 3.6 gb an hour for some parts of the program.
Thought about using SQL server management studio since we've got some experience with that.

On to the traffic simulation:
==> Generating cars with a starting and ending coordinates and other properties
==> Generating cameras at certain GPS coordinates around 8000?
			- Using OpenStreetMaps or GoogleMaps to determine the actual coordinates of a existing route
			- Methods to write the data to a flat file

			
==> Mathematics: 
			- Sides/diagonals inside a square, using vectors (distance and direction from point A to B)
			-Limiting to only UK.
			- Quadratic equations to simulate curves
		    	- Perhaps testing with sinus-functions


==> Database: 
			-Presentation Layer - Business Layer - Data Layer
			-Drawn up in an XML.
			
Probably going to come up with some more questions.


Blog #4 (08/04/2014)
====================
We got home and started brainstorming again, at first sight, we would prefer to go with a car based application since
a camera-based one looks way more complicated than the car one, since the cameras would have to know each other's existence
and data. Although using the car-based approach might consume a lot more memory, we will test this out later, but stick 
with that idea for now. A second pointer: how should we move the car from point A to point B when we're given certain
GPS coordinates? What if we want to move more cars? As discussed today, we will start out by using simple geometric 
functions to simulate movement.

We have been thinking about various ways to simulate this car movement in Java. Since a car will travel a certain
distance over a certain amount of time, it will be necessary for our program to work with some sort of timer that can
keep track of the progression of the vehicle. A first thought we had was using Threads to accomplish this.
Inside the run-method of the thread, we could use a continous while-loop representing the movement of the car,
and perhaps also implement some small things like stopping at traffic lights.

A simple (not worked out) example of this would look like:


    int pauseRedd = 6000;


    public void run()
    { 
	      while (true)
	      {  
            currentTime= System.currentTimeMillis();
            timelap = currentTime - paramTime;

            if (timelap > 50) 
               carflow[index].update();

            if (signal == RED_LIGHT)
            {
               signal = 0;
               traficLightpausingTime = pauseRedd;
            }

	          try
            {
		          Thread.sleep(CONSTANT_PAUSE_TIME + traficLightpausingTime);
	          }
	          catch (InterruptedException e)
	          {
		          break;
	          }
	      }
    }


But before running ahead of ourselves on simulating the movement, we thought it'd be smarter to start out by
thinking about the mathematics needed to do this. A continous movement could be represented by a function where
we increment a variable time and multiply it with the velocity of the vehicle. 

Subsequently we made a sketch on how our database could look like: details about the cars, details about the cameras &
routes and linking the car to a route (or in another scenario: linking a car to a camera).

And finally, we exchanged some thoughts about either writing each car instantly to the database or writing it to a flat
file, like for example a simple .txt file or .xml file which you could later on parse and xecute to write it to the
database. Using the secvond way seemed like a better idea, since it'll consume a lot less memory, plus it will also be
easier to edit and/or insert (poisonous) data later on.




Blog #3 (01/04/2014)
====================
Started the day off by thorougly reading the task description again. We read a few articles about 'Agile software developing methods' , we decided to go with Extreme Programming.
After we understood it 100% we started brainstorming and throwing ideas around on how we would start developing the application.
We made a plan about how we would like to develop the app, then we started brainstorming again to find some extra features, we found an interesting one about altering RBG values from an image.
After we made the plan we slowly started the implementation of some functions. 
So far we can crop an image , split it into a few tiles using the command line.
Tomorrow we'll probably start looking up or reading documentation on how to hide data in the tiles.


Blog #2
===========

We started the day off by finishing up our CryptoLocker, which has two versions of it. 
The first version is the one where we use a symmetric algorithm to encrypt a piece of data and store it in file somewhere, the key used to encrypt the data is stored in a file as well. 
The symmetric algorithm is quite easy to use and understand.
The second version of our CryptoLocker is the one where we use an asymmetric algorithm, which uses 2 keys, a private one and a public one, the keys are stored in a file. 
This version is a little bit trickier since we had to use some sort of RSA algorithm which we aren't familiar with yet. 
We're still trying out a few different versions of it to get more familiar with the encryption and decryption of data.



After that, we started brainstorming about different approaches to hide data inside other data. 
Because we barely have any experience in this field (yet), we started thinking about OpenPuff, which we  already work with in our first assignment last week. 
We wanted to start by taking a deeper look into what is happening behind the scenes when a message gets hidden into an image, while using the OpenPuff's hiding techniques. 
After doing the necessary research, we tried to come up with our own implementation of the act of hiding a byte of data into an image-file, by altering the RGBA values of a pixel of the image.
We worked out an example using a simple modulus operator based algorithm that uses two adjacent pixels to hide one byte of data. 
We chose to use 2 pixels in order to hide one bit of data in every R, G, B and A value of both pixels, together forming the full byte (8 bits). 
We figured if we would have used only one pixel to hide the full byte of data, that would imply we had to alter the RGBA values in a more visible way for the human-eye, and thus make it easier to detect the fact a message was hidden inside the image. 
In case of an image where the Alpha channel is unimportant, we thought an interesting alternative approach would perhaps be to modify one bit of the R, G and B values and all 8 bits of the alpha channel. 
This would allow us to store 11 bits in just one pixel, which is even more than one byte, 1.375 bytes per pixel to be exact. Thus, this means we could store 11 bytes of data in just 8 adjacent pixels, which sounded like a pretty good start to us. 
Unfortunately, we haven't had the chance yet to implement our design into Java-code, but given the idea is fully worked out in our heads and on paper, this will probably/hopefully be something to finish tomorrow.


Blog #1
===========

So after class ended around 11am, we went on another coffee run with Liam and a few other students. 
We exchanged some information about the units they get and the ones we have back home.
After that we went home and gave the cryptolocker another shot. 
We read up and gathered some general information on some terms which we weren�t yet familiar with like AES, the KeyGenerator & Cipher class.
After we figured that out we googled a few simple exercises on how to encrypt and decrypt some string examples. 
That went quite alright so we�re progressing with a steady pace on the cryptolocker. 
Tomorrow we�ll probably finish it and we�ll try to come up with a few ideas on our own.



