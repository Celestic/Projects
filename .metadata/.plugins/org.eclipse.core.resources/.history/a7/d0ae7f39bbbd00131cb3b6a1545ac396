package alpha.java.steganography;

import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;
import javax.swing.JOptionPane;

public class Steganography {
	public Steganography() {
	}

	/**
	 * Handles the addition of text into an image
	 * 
	 * @param message
	 *            The text to hide in the image
	 * @return Returns The image with the text embedded in it
	 */
	public BufferedImage hideMessage(BufferedImage image, String message) {
		// Convert all items to byte arrays: image, message, message length
		byte img[] = getByteData(image);
		byte msg[] = message.getBytes();
		byte len[] = bitConversion(msg.length);

		try {
			encodeText(img, len, 0); // 0 first positiong
			encodeText(img, msg, 32); // 4 bytes of space for length:
										// 4bytes * 8bit = 32 bits
		} catch (Exception e) {
			JOptionPane.showMessageDialog(null,
					"Target File cannot hold message!", "Error",
					JOptionPane.ERROR_MESSAGE);
		}

		return image;
	}

	/**
	 * Extracts the hidden text from an image
	 * 
	 * @param path
	 *            The path (folder) containing the image to extract the message
	 *            from
	 * @param name
	 *            The name of the image to extract the message from
	 * @param type
	 *            Integer representing either basic or advanced encoding
	 */
	public String decodeMessage(BufferedImage image) {
		byte[] decode;

		try {
			decode = decodeText(getByteData(image));

			return (new String(decode));
		} catch (Exception e) {
			JOptionPane.showMessageDialog(null,
					"There is no hidden message in this image!", "Error",
					JOptionPane.ERROR_MESSAGE);

			return "";
		}
	}

	/**
	 * Gets the byte array of an image
	 * 
	 * @param image
	 *            The image to get byte data from
	 * @return Returns the byte array of the image supplied
	 * @see Raster
	 * @see WritableRaster
	 * @see DataBufferByte
	 */
	private byte[] getByteData(BufferedImage image) {
		WritableRaster raster = image.getRaster();
		DataBufferByte buffer = (DataBufferByte) raster.getDataBuffer();

		return buffer.getData();
	}

	/**
	 * Generates proper byte format of an integer
	 * 
	 * @param i
	 *            The integer to convert
	 * @return Returns a byte[4] array converting the supplied integer into
	 *         bytes
	 */
	private byte[] bitConversion(int i) {
		// Originally integers cast into bytes
		// byte byte7 = (byte)((i & 0xFF00000000000000L) >>> 56);
		// byte byte6 = (byte)((i & 0x00FF000000000000L) >>> 48);
		// byte byte5 = (byte)((i & 0x0000FF0000000000L) >>> 40);
		// byte byte4 = (byte)((i & 0x000000FF00000000L) >>> 32);

		// Only using 4 bytes
		byte byte3 = (byte) ((i & 0xFF000000) >>> 24); // 0
		byte byte2 = (byte) ((i & 0x00FF0000) >>> 16); // 0
		byte byte1 = (byte) ((i & 0x0000FF00) >>> 8); // 0
		byte byte0 = (byte) ((i & 0x000000FF));

		// {0,0,0,byte0} is equivalent, since all shifts >=8 will be 0

		return (new byte[] { byte3, byte2, byte1, byte0 });
	}

	/**
	 * Encode an array of bytes into another array of bytes at a supplied offset
	 * 
	 * @param Image
	 *            Array of data representing an image
	 * @param Addition
	 *            Array of data to add to the supplied image data array
	 * @param Offset
	 *            The offset into the image array to add the addition data
	 * @return Returns data Array of merged image and addition data
	 */
	private byte[] encodeText(byte[] image, byte[] addition, int offset) {
		// Check that the data + offset will fit in the image
		if (addition.length + offset > image.length) {
			throw new IllegalArgumentException("File not long enough!");
		}

		// Loop through each addition byte
		for (int i = 0; i < addition.length; ++i) {
			// Loop through the 8 bits of each byte
			int add = addition[i];

			for (int bit = 7; bit >= 0; --bit, ++offset) // ensure the new
															// offset value
															// carries on
															// through both
															// loops
			{
				// assign an integer to b, shifted by bit spaces AND 1
				// a single bit of the current byte
				int b = (add >>> bit) & 1;
				// assign the bit by taking: [(previous byte value) AND 0xfe] OR
				// bit to add
				// changes the last bit of the byte in the image to be the bit
				// of addition
				image[offset] = (byte) ((image[offset] & 0xFE) | b);
			}
		}
		return image;
	}

	/**
	 * Retrieves hidden text from an image
	 * 
	 * @param Image
	 *            Array of data, representing an image
	 * @return Array of data which contains the hidden text
	 */
	private byte[] decodeText(byte[] image) {
		int length = 0;
		int offset = 32;

		// Loop through 32 bytes of data to determine text length
		for (int i = 0; i < 32; ++i) // i=24 will also work, as only the 4th
										// byte contains real data
		{
			length = (length << 1) | (image[i] & 1);
		}

		byte[] result = new byte[length];

		// Loop through each byte of text
		for (int b = 0; b < result.length; ++b) {
			// Loop through each bit within a byte of text
			for (int i = 0; i < 8; ++i, ++offset) {
				// Assign bit: [(new byte value) << 1] OR [(text byte) AND 1]
				result[b] = (byte) ((result[b] << 1) | (image[offset] & 1));
			}
		}

		return result;
	}

	// -------------------------------------------------------------------------------------------------------
	public void stegnography(BufferedImage bimg, String msg, String filename) {

		int w = bimg.getWidth();
		int h = bimg.getHeight();
		// ***************************************
		//String msg="Hide this message:)";
		System.out.println("message=" + msg + " length=" + msg.length());
		// ***************************************

		if (msg.length() > 255) {
			System.out.println("MESSAGE IS LARGE THAN 255 CHARACTERS");
		} else if (msg.length() * 11 > w * h) {
			System.out.println("Image is too small");
		} else {

			// -------------------------------------------
			byte[] msgbytes = msg.getBytes();

			int msglendecode = (bimg.getRGB(0, 0) >> 8) << 8;

			msglendecode |= msg.length();
			bimg.setRGB(0, 0, msglendecode);// hidig msg length at first
											// position

			// System.out.println("\npixel at position (0,0) ");
			// bitpattern(bimg.getRGB(0,0) );

			for (int i = 1, msgpos = 0, row = 0, j = 0; row < h; row++) {
				for (int col = 0; col < w && j < msgbytes.length; col++, i++) {

					if (i % 11 == 0) {

						int rgb = bimg.getRGB(col, row);

						int a = ((rgb >> 24) & 0xff);

						int r = (((rgb >> 16) & 0xff) >> 3) << 3;
						r = r | (msgbytes[msgpos] >> 5);

						int g = (((rgb >> 8) & 0xff) >> 3) << 3;
						g = g | ((msgbytes[msgpos] >> 2) & 7);

						int b = ((rgb & 0xff) >> 2) << 2;
						b = b | (msgbytes[msgpos] & 0x3);

						rgb = 0;
						rgb = (rgb | (a << 24));
						rgb = (rgb | (r << 16));
						rgb = (rgb | (g << 8));

						rgb = (rgb | b);

						bimg.setRGB(col, row, rgb);

						msgpos++;
						j++;

						// bitpattern(bimg.getRGB(col,row));

					}

				}// for 2
			}// for 1

	//		Image image = new ImageIcon(bimg);
//			jLabel3.setIcon(image);

			try {

				File outputfile = new File(
						"D:/gegevens/desktop/output.png");
				ImageIO.write(bimg, "png", outputfile);
			} catch (IOException e) {
				System.out.println("error in saving image ");
			}

			// -------------------------------------------------
		}// else
		// decoding
		// part----------------------------------------------------------------------

	}

	// /////////////////////////////////////////////////////////////////////
	private void decodestegnography(BufferedImage bimg) {

		System.out.println("in decode");

		int w = bimg.getWidth(), h = bimg.getHeight();
		bitpattern(bimg.getRGB(0, 0));
		int msglength = (bimg.getRGB(0, 0) & 0xff);
		bitpattern(msglength);
		System.out.println("Message Length=" + msglength);

	
		for (int row = 0, j = 0, i = 1; row < h; row++) {
			for (int col = 0; col < w && j < msglength; col++, i++) {

				if (i % 11 == 0) {
					int result = bimg.getRGB(col, row);

					int charatpos = (((result >> 16) & 0x7) << 5);

					charatpos |= (((result >> 8) & 0x7) << 2);

					charatpos |= ((result & 0x3));

					jTextField1.setText(jTextField1.getText()
							+ (char) charatpos);

					j++;
				}
			}
		}

		System.out.println("decoding done");
	}// function
}